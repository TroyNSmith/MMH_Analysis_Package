import mde.mdevaluate as mde
import numpy as np
import pandas as pd

from datetime import datetime
from functools import partial
from pathlib import Path

from .utils.coordinates import multi_radial_selector
from .utils.types import BaseAnalysis
from .utils.basemodels import Params, Metadata, Results
from .utils import plotting


class IncoherentScatteringFunction(BaseAnalysis):
    def __init__(
        self,
        coords: mde.coordinates.CoordinatesMap,
        coords_type: str,
        params: Params,
        q_magnitude: float,
        num_segments: int = 500,
        skip: float = 0.1,
    ):
        """
        Initialize analysis related to incoherent scattering functions.

        :param coords: CoordinateFrame object generated by mdevaluate.
        :param q_magnitude: Float value of scattering vector (q) magnitude.
        :param num_segments: Integer number of starting points in the shifted correlation.
        :param skip: Fraction of the trajectory to skip at its beginning.
        """
        self._coords = coords
        self._q_magnitude = q_magnitude
        self._num_segments = num_segments
        self._skip = skip

        self._params = params
        self._params.q_magnitude=q_magnitude
        self._params.num_segments=num_segments
        self._params.skip=skip

        self._metadata = Metadata()
        self._results = Results()

    @property
    def has_results(self):
        return hasattr(self, "_results_df")

    def calculate(
        self,
        radially_resolved: bool = False,
        pore_diameter: float = None,
        num_radial_bins: int = 10,
        radius_buffer=0.1,
    ) -> pd.DataFrame:
        """
        Calculate the incoherent scattering function.

        :param radially_resolved: Generate radially resolved results.
        :param num_radial_bins: Integer number of cylinders to use in radially resolved analysis.
        :param diameter: Diameter of the pore being radially binned.
        :param radius_buffer: Distance to include beyond the pore diameter for binning.
        """
        print("Calculating ISF...")

        if radially_resolved:
            assert pore_diameter > 0.0, (
                "Pore diameter must be provided for radially resolved results."
            )

            self._params.radially_resolved = radially_resolved
            self._params.pore_diameter = pore_diameter
            self._params.num_radial_bins = num_radial_bins
            self._params.radius_buffer = radius_buffer

            radius = pore_diameter / 2 + radius_buffer
            radial_bins = np.arange(
                0.0, radius + radius / num_radial_bins, radius / num_radial_bins
            )

            column_labels = ["Time / ps"] + [
                f"{radial_bins[i]:.2f} to {radial_bins[i + 1]:.2f} nm"
                for i in range(len(radial_bins) - 1)
            ]

            times, results = mde.correlation.shifted_correlation(
                partial(mde.correlation.isf, q=self._q_magnitude),
                self._coords,
                selector=partial(multi_radial_selector, radial_bins=radial_bins),
                segments=self._num_segments,
                skip=self._skip,
            )

            df = pd.DataFrame(np.column_stack([times, *results]), columns=column_labels)

        else:
            column_labels = ["Time / ps", "ISF"]

            times, results = mde.correlation.shifted_correlation(
                partial(mde.correlation.isf, q=self._q_magnitude),
                self._coords,
                segments=self._num_segments,
                skip=self._skip,
            )

            df = pd.DataFrame(np.column_stack([times, results]), columns=column_labels)

        self._results_df = df

        self._metadata.analysis_last_performed = datetime.now()

        return df

    def plot(self, output_directory: Path):
        if not self.has_results:
            raise LookupError("Calculate ISF before plotting.")
        
        module_name = self.__class__.__name__.replace("Function", "")
        
        def isf_plot_func(df: pd.DataFrame, out_path: Path):
            plotting.plot_line(
                output_path=out_path,
                x_data=self._results_df.iloc[:, 0],
                y_data=self._results_df.iloc[:, 1:],
                x_axis_label="t / ps",
                x_axis_scale="log",
                y_axis_label=r"$F(\|\mathbf{q}\|, t)$",
            )

        plotting.plot_from_log(
            module_name=module_name,
            output_directory=output_directory,
            current_params=self._params.model_dump(),
            plot_func=isf_plot_func,
        )

class RadialDistributionFunction(BaseAnalysis):
    def __init__(
        self,
        coords: mde.coordinates.CoordinatesMap,
        coords_type: str,
        params: Params,
        num_segments: int = 500,
        skip: float = 0.1,
    ):
        """
        Initialize analysis related to radial distribution functions.

        :param coords: CoordinateFrame object generated by mdevaluate.
        :param num_segments: Integer number of starting points in the shifted correlation.
        :param skip: Fraction of the trajectory to skip at its beginning.
        """
        self._coords = coords
        self._coords_type = coords_type
        self._num_segments = num_segments
        self._skip = skip

        self._params = params
        self._params.num_segments=num_segments
        self._params.skip=skip

        self._metadata = Metadata()
        self._results = Results()

    @property
    def has_results(self):
        return hasattr(self, "_results_df")
    
    @property
    def q_magnitude(self):
        y_max_idx = self._results_df.iloc[:, 1].idxmax()
        x_at_max_y = self._results_df.iloc[y_max_idx, 0]
        q_magnitude = 2 * np.pi / x_at_max_y
        return q_magnitude
    
    def calculate(
        self,
        num_radial_bins: int = 500,
        max_search_radius: float = 2.5,
        mode: str = "total",
        res_name: str = None,
        atoms: list = None,
    ) -> pd.DataFrame:
        """
        Calculate the incoherent scattering function.

        :param mode: "total" | "intra" | "inter"
        """
        print(f"Calculating {mode} RDF...")

        bins = np.arange(0, max_search_radius, 0.01)
        column_labels = ["r / nm", "G(r)"]

        if self._coords_type == "com":

            results = mde.distribution.time_average(
                partial(mde.distribution.rdf, bins=bins),
                self._coords,
                segments=self._num_segments,
                skip=0.01,
            )
            df = pd.DataFrame(np.column_stack([bins[:-1], results]), columns=column_labels)
            self._results_df = df
            self._results.q_magnitude = round(float(self.q_magnitude), 3)

        else:
            assert res_name is not None, "Residue name must be provided for non center of mass RDFs."
            assert len(atoms) == 2, "Atoms must be provided for non center of mass RDFs."

            self._params.res_name = res_name
            self._params.atoms = str(f"{atoms[0]}, {atoms[1]}")

            self._params.analysis_mode = mode

            atom_1_coords = self._coords.subset(
                atom_name=atoms[0], residue_name=res_name
            )

            atom_2_coords = self._coords.subset(
                atom_name=atoms[1], residue_name=res_name
            )

            results = mde.distribution.time_average(
                function=partial(mde.distribution.rdf, bins=bins, mode=mode),
                coordinates=atom_1_coords,
                coordinates_b=atom_2_coords,
                segments=self._num_segments,
            )
            
            df = pd.DataFrame(np.column_stack([bins[:-1], results]), columns=column_labels)

            self._results_df = df

        self._metadata.analysis_last_performed = datetime.now()

        return df
    
    def plot():
        raise NotImplementedError