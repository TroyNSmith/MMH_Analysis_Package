import numpy as np
import pandas as pd

from functools import partial

from . import helpers
from .. import mdevaluate as mde


def mean_square_displacement(
    coords: mde.coordinates.CoordinatesMap,
    axis: str = "all",
    num_segments: int = 500,
    radially_resolved: bool = False,
    pore_diameter: float = 0.0,
    num_bins = 5,
) -> pd.DataFrame:
    """
    :param coords: CoordinatesMap generated by mdevaluate.
    :param axis: "all", "xy", "xz", "yz", "x", "y", "z"
    :param num_segments: Number of starting points in shifted correlation.
    :param radially_resolved: Whether to divide the pore into cylinders for radially separated results.
    :param pore_diameter: Diameter of the pore in nm. (Required if radially_resolved)
    :param num_bins: Number of cylinders to divide the radial analysis into.
    :return results: Pandas DataFrame with x-values, y-values, and appropriate column labels.
    """
    if radially_resolved:
        assert pore_diameter > 0, (
            "Specify the pore diameter when performing radial analysis."
        )

        radius_buffer = 0.1
        radius = pore_diameter / 2 + radius_buffer

        bins = np.arange(0.0, radius + radius / num_bins, radius / num_bins)

        column_labels = ["t / ps"] + [
            f"{bins[i]:.1f} to {bins[i + 1]:.1f} nm" for i in range(len(bins) - 1)
        ]

        times, results = mde.correlation.shifted_correlation(
            partial(mde.correlation.msd, axis=axis),
            coords,
            selector=partial(helpers.multi_radial_selector, bins=bins),
            segments=num_segments,
            skip=0.1,
            average=True,
        )

        df = pd.DataFrame(np.column_stack([times, *results]), columns=column_labels)

    else:
        column_labels = ["t / ps", f"MSD ({axis})"]
        times, results = mde.correlation.shifted_correlation(
            partial(mde.correlation.msd, axis=axis), coords, segments=num_segments
        )
        df = pd.DataFrame(np.column_stack([times, results]), columns=column_labels)

    return df


def incoherent_scattering_function(
    coords: mde.coordinates.CoordinatesMap,
    q_val: float,
    num_segments: int = 500,
    radially_resolved: bool = False,
    pore_diameter: float = 0.0,
    num_bins: int = 3,
) -> pd.DataFrame:
    """
    :param coords: CoordinatesMap generated by mdevaluate.
    :param q_val: Magnitude of the scattering vector, q.
    :param num_segments: Number of starting points in shifted correlation.
    :param radially_resolved: Whether to divide the pore into cylinders for radially separated results.
    :param pore_diameter: Diameter of the pore in nm. (Providing a diameter returns ISF results for the inner and outer thirds of the pore)
    :param num_bins: Number of cylinders to divide the radial analysis into.
    :return results: Pandas DataFrame with x-values, y-values, and appropriate column labels. times: df.iloc[:, 0] | results: df. iloc[:, 1:]
    """
    if radially_resolved:
        assert pore_diameter > 0, (
            "Specify the pore diameter when performing radial analysis."
        )
        radius_buffer = 0.1
        radius = pore_diameter / 2 + radius_buffer

        bins = np.arange(0.0, radius + radius / num_bins, radius / num_bins)

        column_labels = ["t / ps"] + [
            f"{bins[i]:.1f} to {bins[i + 1]:.1f} nm" for i in range(len(bins) - 1)
        ]

        times, results = mde.correlation.shifted_correlation(
            partial(mde.correlation.isf, q=q_val),
            coords,
            selector=partial(helpers.multi_radial_selector, bins=bins),
            segments=num_segments,
            skip=0.1,
        )

        df = pd.DataFrame(np.column_stack([times, *results]), columns=column_labels)

    else:
        column_labels = ["time / ps", "Total"]

        times, results = mde.correlation.shifted_correlation(
            partial(mde.correlation.isf, q=q_val), coords, segments=num_segments
        )

        df = pd.DataFrame(
            np.column_stack([times, results]),
            columns=column_labels,
        )

    return df


def non_gaussian_parameter(
    coords: mde.coordinates.CoordinatesMap,
    num_segments: int = 500,
) -> pd.DataFrame:
    """
    :param coords: CoordinatesMap generated by mdevaluate.
    :param num_segments: Number of starting points in shifted correlation.
    :return results: Pandas DataFrame with x-values, y-values, and appropriate column labels. times: df.iloc[:, 0] | results: df. iloc[:, 1:]
    """
    column_labels = ["t / ps", "NGP(t)"]

    times, results = mde.correlation.shifted_correlation(
        mde.correlation.non_gaussian_parameter, coords, segments=num_segments
    )

    df = pd.DataFrame(np.column_stack([times, results]), columns=column_labels)

    return df


def rotational_correlations(
    vectors: mde.coordinates.CoordinatesMap, num_segments: int = 500
) -> pd.DataFrame:
    """
    :param vectors: CoordinatesMap of vectorized residues generated by mdevaluate.
    :param num_segments: Number of starting points in shifted correlation.
    :return results: Pandas DataFrame with x-values, y-values, and appropriate column labels. times: df.iloc[:, 0] | results: df. iloc[:, 1:]
    """
    column_labels = ["t / ps", "n = 1", "n = 2"]

    times, results_f1 = mde.correlation.shifted_correlation(
        partial(mde.correlation.rotational_autocorrelation, order=1),
        vectors,
        segments=num_segments,
        skip=0.1,
        average=True,
    )

    times, results_f2 = mde.correlation.shifted_correlation(
        partial(mde.correlation.rotational_autocorrelation, order=2),
        vectors,
        segments=num_segments,
        skip=0.1,
        average=True,
    )

    df = pd.DataFrame(
        np.column_stack([times, results_f1, results_f2]), columns=column_labels
    )

    return df


def chi_4_susceptibility(
    coords: mde.coordinates.CoordinatesMap, q_val: float, num_segments: int = 500
) -> pd.DataFrame:
    """
    :param coords: CoordinatesMap generated by mdevaluate.
    :param q_val: Magnitude of the scattering vector, q.
    :param num_segments: Number of starting points in shifted correlation.
    :return DataFrame: TIMES df.iloc[ ':' , 0 ] | RESULTS df. iloc[ ':' , 1 ] | ROLLING AVERAGE df.iloc[ ':' , 2 ]
    """
    column_labels = ["t / ps", "X_4(t)"]

    times, results = mde.correlation.shifted_correlation(
        partial(mde.correlation.isf, q=q_val),
        coords,
        average=True,
        segments=num_segments,
    )

    df = pd.DataFrame(
        np.column_stack([times, results]),
        columns=column_labels,
    )

    return df


def van_hove_rotation(
    vectors: mde.coordinates.CoordinatesMap, num_segments: int = 500
) -> pd.DataFrame:
    """
    :param vectors: CoordinatesMap of vectorized residues generated by mdevaluate.
    :param num_segments: Number of starting points in shifted correlation.
    :return DataFrame: ANGLES = df.iloc[ ':' , 0 ] | TIMES = df.columns | F(Î¸, t) = df.iloc[ ':' , 1: ]
    """

    def _angle_dist(start, end, bins):
        scalar_product = (start * end).sum(axis=-1)
        angle = np.arccos(scalar_product)
        angle = angle[(angle >= 0) * (angle <= np.pi)]
        histogram, _ = np.histogram(angle * 360 / (2 * np.pi), bins)
        return 1 / len(start) * histogram

    bins = np.linspace(0, 180, 361)

    times, results = mde.correlation.shifted_correlation(
        function=partial(_angle_dist, bins=bins),
        frames=vectors,
        segments=num_segments,
        skip=0.1,
        points=8,
    )
    
    column_labels = ["angle / degrees"] + [
            f"{t / 1000:.0f} ns" for t in times
        ]

    bin_centers = np.array(
        [0.5 * (bins[i] + bins[i + 1]) for i in range(len(bins) - 1)]
    )

    df = pd.DataFrame(np.column_stack([bin_centers, results.T]), columns=column_labels)

    return df


def van_hove_translation(
    coords: mde.coordinates.CoordinatesMap,
    num_segments: int,
    pore_diameter: float,
    num_bins: int = 3,
) -> pd.DataFrame:
    """
    Calculates van Hove translational dynamics based on centers of masses.

    Args:
        com: NumPy array containing the center of mass coordinates.
        diameter: Diameter of the pore.
        segments: Number of segments to divide the trajectory into.
        pore: Whether or not the system is a pore.

    Returns:
        * NDArray: A NumPy array containing the van Hove translational dynamics at the wall of the pore.
        * NDArray: A NumPy array containing the van Hove translational dynamics at the center of the pore.
        NDArray: A NumPy array containing the bins used.

        * If the system is a pore, otherwise only the overall van Hove translational array is returned.
    """
    radius_buffer = 0.1
    radius = pore_diameter / 2 + radius_buffer

    bins = np.arange(0.0, radius + radius / num_bins, radius / num_bins)

    times, results = mde.correlation.shifted_correlation(
        partial(mde.correlation.van_hove_self, bins=bins),
        coords,
        segments=num_segments,
        skip=0.1,
        points=8,
    )

    column_labels = ["r / nm"] + [
            f"{t / 1000:.0f} ns" for t in times
        ]

    bin_centers = np.array(
        [0.5 * (bins[i] + bins[i + 1]) for i in range(len(bins) - 1)]
    )

    df = pd.DataFrame(np.column_stack([bin_centers, results.T]), columns=column_labels)

    return df
