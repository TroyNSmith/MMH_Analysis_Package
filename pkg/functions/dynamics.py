import helpers
import pkg.mdevaluate as mde
import numpy as np
import pandas as pd

from functools import partial


def mean_square_displacement(
    coords: mde.coordinates.CoordinatesMap,
    axis: str = "all",
    num_segments: int = 500,
    radially_resolved: bool = False,
    pore_diameter: float = 0.0,
) -> pd.DataFrame:
    """
    :param coords: CoordinatesMap generated by mdevaluate.
    :param axis: "all", "xy", "xz", "yz", "x", "y", "z"
    :param num_segments: Number of starting points in shifted correlation.
    :param radially_resolved: Whether to divide the pore into cylinders for radially separated results.
    :param pore_diameter: Diameter of the pore in nm. (Required if radially_resolved)
    :return results: Pandas DataFrame with x-values, y-values, and appropriate column labels.
    """
    if radially_resolved:
        assert pore_diameter > 0, (
            "Specify the pore diameter when performing radial analysis."
        )

        bins = np.arange(0.0, pore_diameter / 2 + 0.1, 0.1)
        bin_centers = (bins[:-1] + bins[1:]) / 2

        column_labels = "t / ps," + ",".join(
            [f"{bin_centers[i]} nm" for i in range(len(bin_centers))]
        )

        times, results = mde.correlation.shifted_correlation(
            partial(mde.correlation.msd, axis=axis),
            coords,
            selector=partial(helpers.multi_radial_selector, bins=bins),
            segments=num_segments,
            skip=0.1,
            average=True,
        )

        df = pd.DataFrame(np.column_stack([times, *results]), columns=column_labels)

    else:
        column_labels = f"time / ps, MSD ({axis})"
        time, results = mde.correlation.shifted_correlation(
            partial(mde.correlation.msd, axis=axis), coords, segments=num_segments
        )
        df = pd.DataFrame(np.column_stack([times, results]), columns=column_labels)

    return df


def incoherent_scattering_function(
    coords: mde.coordinates.CoordinatesMap,
    q_val: float,
    num_segments: int = 500,
    radially_resolved: bool = False,
    pore_diameter: float = 0.0,
    num_bins: int = 3,
) -> pd.DataFrame:
    """
    :param coords: CoordinatesMap generated by mdevaluate.
    :param q_val: Magnitude of the scattering vector, q.
    :param num_segments: Number of starting points in shifted correlation.
    :param radially_resolved: Whether to divide the pore into cylinders for radially separated results.
    :param pore_diameter: Diameter of the pore in nm. (Providing a diameter returns ISF results for the inner and outer thirds of the pore)
    :param num_bins: Number of cylinders to divide the radial analysis into.
    :return results: Pandas DataFrame with x-values, y-values, and appropriate column labels. times: df.iloc[:, 0] | results: df. iloc[:, 1:]
    """
    if radially_resolved:
        assert pore_diameter > 0, (
            "Specify the pore diameter when performing radial analysis."
        )
        radius_buffer = 0.1
        radius = pore_diameter / 2 + radius_buffer

        bins = np.arange(0.0, radius + radius / num_bins, radius / num_bins)

        column_labels = "# q = {q_val:.1f} # t / ps," + ",".join(
            [f"{bins[i]}: {bins[i + 1]}" for i in range(len(bins) - 1)]
        )

        times, results = mde.correlation.shifted_correlation(
            partial(mde.correlation.isf, q=q_val),
            coords,
            selector=partial(helpers.multi_radial_selector, bins=bins),
            segments=num_segments,
            skip=0.1,
        )

        df = pd.DataFrame(np.column_stack([times, *results]), columns=column_labels)

    else:
        column_labels = f"time / ps, S({q_val:.1f}, t)"

        times, results = mde.correlation.shifted_correlation(
            partial(mde.correlation.isf, q=q_val), coords, segments=num_segments
        )

        df = pd.DataFrame(
            np.column_stack([times, results]),
            columns=column_labels,
        )

    return df


def non_gaussian_parameter(
    coords: mde.coordinates.CoordinatesMap,
    num_segments: int = 500,
) -> pd.DataFrame:
    """
    :param coords: CoordinatesMap generated by mdevaluate.
    :param num_segments: Number of starting points in shifted correlation.
    :return results: Pandas DataFrame with x-values, y-values, and appropriate column labels. times: df.iloc[:, 0] | results: df. iloc[:, 1:]
    """
    column_labels = "time / ps, NGP(t)"

    times, results = mde.correlation.shifted_correlation(
        mde.correlation.non_gaussian_parameter, coords, segments=num_segments
    )

    df = pd.DataFrame(np.column_stack([times, results]), columns=column_labels)

    return df


def rotational_correlations(
    vectors: mde.coordinates.CoordinatesMap, num_segments: int = 500
) -> pd.DataFrame:
    """
    :param vectors: CoordinatesMap of vectorized residues generated by mdevaluate.
    :param num_segments: Number of starting points in shifted correlation.
    :return results: Pandas DataFrame with x-values, y-values, and appropriate column labels. times: df.iloc[:, 0] | results: df. iloc[:, 1:]
    """
    column_labels = "time / ps, C_1(t), C_2(t)"

    times, results_f1 = mde.correlation.shifted_correlation(
        partial(mde.correlation.rotational_autocorrelation, order=1),
        vectors,
        segments=num_segments,
        skip=0.1,
        average=True,
    )

    times, results_f2 = mde.correlation.shifted_correlation(
        partial(mde.correlation.rotational_autocorrelation, order=2),
        vectors,
        segments=num_segments,
        skip=0.1,
        average=True,
    )

    df = pd.DataFrame(
        np.column_stack([times, results_f1, results_f2]), columns=column_labels
    )

    return df


def chi_4_susceptibility(
    coords: mde.coordinates.CoordinatesMap, q_val: float, num_segments: int = 500
) -> pd.DataFrame:
    """
    :param coords: CoordinatesMap generated by mdevaluate.
    :param q_val: Magnitude of the scattering vector, q.
    :param num_segments: Number of starting points in shifted correlation.
    :return DataFrame: TIMES df.iloc[ ':' , 0 ] | RESULTS df. iloc[ ':' , 1 ] | ROLLING AVERAGE df.iloc[ ':' , 2 ]
    """
    column_labels = "t / ps, X_4(t), X̄_4(t)"

    times, results = mde.correlation.shifted_correlation(
        partial(mde.correlation.isf, q=q_val),
        coords,
        average=False,
        segments=num_segments,
    )

    chi4_raw = len(coords[0]) * results.var(axis=0) * 1e5
    chi4_smooth = mde.utils.moving_average(chi4_raw, 5)

    df = pd.DataFrame(
        np.column_stack([times[2:-2], chi4_raw[2:-2], chi4_smooth]),
        columns=column_labels,
    )

    return df


def van_hove_rotation(
    vectors: mde.coordinates.CoordinatesMap, num_segments: int = 500
) -> pd.DataFrame:
    """
    :param vectors: CoordinatesMap of vectorized residues generated by mdevaluate.
    :param num_segments: Number of starting points in shifted correlation.
    :return DataFrame: ANGLES = df.iloc[ ':' , 0 ] | TIMES = df.columns | F(θ, t) = df.iloc[ ':' , 1: ]
    """

    def _angle_dist(start, end, bins):
        scalar_product = (start * end).sum(axis=-1)
        angle = np.arccos(scalar_product)
        angle = angle[(angle >= 0) * (angle <= np.pi)]
        histogram, _ = np.histogram(angle * 360 / (2 * np.pi), bins)
        return 1 / len(start) * histogram

    bins = np.linspace(0, 180, 361)

    times, results = mde.correlation.shifted_correlation(
        function=partial(_angle_dist, bins=bins),
        frames=vectors,
        segments=num_segments,
        skip=0.1,
        points=8,
    )

    column_labels = "angle / degrees," + ",".join([f"{t / 1000:.0f} ns" for t in times])

    bin_centers = np.array(
        [0.5 * (bins[i] + bins[i + 1]) for i in range(len(bins) - 1)]
    )

    df = pd.DataFrame(np.column_stack([bin_centers, results.T]), columns=column_labels)

    return df


def van_hove_translation(
    coords: mde.coordinates.CoordinatesMap,
    num_segments: int,
    pore_diameter: float,
    num_bins: int = 3,
) -> pd.DataFrame:
    """
    Calculates van Hove translational dynamics based on centers of masses.

    Args:
        com: NumPy array containing the center of mass coordinates.
        diameter: Diameter of the pore.
        segments: Number of segments to divide the trajectory into.
        pore: Whether or not the system is a pore.

    Returns:
        * NDArray: A NumPy array containing the van Hove translational dynamics at the wall of the pore.
        * NDArray: A NumPy array containing the van Hove translational dynamics at the center of the pore.
        NDArray: A NumPy array containing the bins used.

        * If the system is a pore, otherwise only the overall van Hove translational array is returned.
    """
    radius_buffer = 0.1
    radius = pore_diameter / 2 + radius_buffer

    bins = np.arange(0.0, radius + radius / num_bins, radius / num_bins)

    times, results = mde.correlation.shifted_correlation(
        partial(mde.correlation.van_hove_self, bins=bins),
        coords,
        segments=num_segments,
        skip=0.1,
        points=8,
    )

    column_labels = "r / nm," + ",".join([f"{t / 1000:.0f} ns" for t in times])

    bin_centers = np.array(
        [0.5 * (bins[i] + bins[i + 1]) for i in range(len(bins) - 1)]
    )

    df = pd.DataFrame(np.column_stack([bin_centers, results.T]), columns=column_labels)

    return df
