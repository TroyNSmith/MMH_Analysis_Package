import numpy as np
import pandas as pd

from functools import partial

from .. import mdevaluate as mde

from ..utils.coordinates import multi_radial_selector


def mean_square_displacement(
    coords: mde.coordinates.CoordinatesMap,
    axis: str = "all",
    num_segments: int = 500,
    radially_resolved: bool = False,
    pore_diameter: float = 0.0,
    num_bins=5,
) -> pd.DataFrame:
    """
    :param coords: CoordinatesMap generated by mdevaluate.
    :param axis: "all", "xy", "xz", "yz", "x", "y", "z"
    :param num_segments: Number of starting points in shifted correlation.
    :param radially_resolved: Whether to divide the pore into cylinders for radially separated results.
    :param pore_diameter: Diameter of the pore in nm. (Required if radially_resolved)
    :param num_bins: Number of cylinders to divide the radial analysis into.
    :return results: Pandas DataFrame with x-values, y-values, and appropriate column labels.
    """
    if radially_resolved:
        assert pore_diameter > 0, (
            "Specify the pore diameter when performing radial analysis."
        )

        radius_buffer = 0.1
        radius = pore_diameter / 2 + radius_buffer

        bins = np.arange(0.0, radius + radius / num_bins, radius / num_bins)

        column_labels = ["t / ps"] + [
            f"{bins[i]:.1f} to {bins[i + 1]:.1f} nm" for i in range(len(bins) - 1)
        ]

        times, results = mde.correlation.shifted_correlation(
            partial(mde.correlation.msd, axis=axis),
            coords,
            selector=partial(multi_radial_selector, bins=bins),
            segments=num_segments,
            skip=0.1,
            average=True,
        )

        df = pd.DataFrame(np.column_stack([times, *results]), columns=column_labels)

    else:
        column_labels = ["t / ps", f"MSD ({axis})"]
        times, results = mde.correlation.shifted_correlation(
            partial(mde.correlation.msd, axis=axis), coords, segments=num_segments
        )
        df = pd.DataFrame(np.column_stack([times, results]), columns=column_labels)

    return df


def incoherent_scattering_function(
    coords: mde.coordinates.CoordinatesMap,
    q_val: float,
    num_segments: int = 500,
    radially_resolved: bool = False,
    pore_diameter: float = 0.0,
    num_bins: int = 3,
) -> pd.DataFrame:
    """
    :param coords: CoordinatesMap generated by mdevaluate.
    :param q_val: Magnitude of the scattering vector, q.
    :param num_segments: Number of starting points in shifted correlation.
    :param radially_resolved: Whether to divide the pore into cylinders for radially separated results.
    :param pore_diameter: Diameter of the pore in nm. (Providing a diameter returns ISF results for the inner and outer thirds of the pore)
    :param num_bins: Number of cylinders to divide the radial analysis into.
    :return results: Pandas DataFrame with x-values, y-values, and appropriate column labels. times: df.iloc[:, 0] | results: df. iloc[:, 1:]
    """
    if radially_resolved:
        assert pore_diameter > 0, (
            "Specify the pore diameter when performing radial analysis."
        )
        radius_buffer = 0.1
        radius = pore_diameter / 2 + radius_buffer

        bins = np.arange(0.0, radius + radius / num_bins, radius / num_bins)

        column_labels = ["t / ps"] + [
            f"{bins[i]:.1f} to {bins[i + 1]:.1f} nm" for i in range(len(bins) - 1)
        ]

        times, results = mde.correlation.shifted_correlation(
            partial(mde.correlation.isf, q=q_val),
            coords,
            selector=partial(multi_radial_selector, bins=bins),
            segments=num_segments,
            skip=0.1,
        )

        df = pd.DataFrame(np.column_stack([times, *results]), columns=column_labels)

    else:
        column_labels = ["time / ps", "Total"]

        times, results = mde.correlation.shifted_correlation(
            partial(mde.correlation.isf, q=q_val), coords, segments=num_segments
        )

        df = pd.DataFrame(
            np.column_stack([times, results]),
            columns=column_labels,
        )

    return df


def non_gaussian_parameter(
    coords: mde.coordinates.CoordinatesMap,
    num_segments: int = 500,
) -> pd.DataFrame:
    """
    :param coords: CoordinatesMap generated by mdevaluate.
    :param num_segments: Number of starting points in shifted correlation.
    :return results: Pandas DataFrame with x-values, y-values, and appropriate column labels. times: df.iloc[:, 0] | results: df. iloc[:, 1:]
    """
    column_labels = ["t / ps", "NGP(t) Original", "NGP(t) Updated"]

    times, results_original = mde.correlation.shifted_correlation(
        mde.correlation.non_gaussian_parameter, coords, segments=num_segments
    )

    times, results_updated = mde.correlation.shifted_correlation(
        mde.correlation.revised_alpha_parameter,
        coords,
        segments=num_segments,
        average=False,
    )

    second_moment = results_updated[:, :, 1].mean(axis=0)
    fourth_moment = results_updated[:, :, 2].mean(axis=0)

    alpha = (
        fourth_moment / ((1 + 2 / 3) * second_moment**2)
    ) - 1  # finally alpha_2 is calculated

    df = pd.DataFrame(
        np.column_stack([times, results_original, alpha]), columns=column_labels
    )

    return df


def rotational_correlations(
    vectors: mde.coordinates.CoordinatesMap, num_segments: int = 500
) -> pd.DataFrame:
    """
    :param vectors: CoordinatesMap of vectorized residues generated by mdevaluate.
    :param num_segments: Number of starting points in shifted correlation.
    :return results: Pandas DataFrame with x-values, y-values, and appropriate column labels. times: df.iloc[:, 0] | results: df. iloc[:, 1:]
    """
    column_labels = ["t / ps", "n = 1", "n = 2"]

    times, results_f1 = mde.correlation.shifted_correlation(
        partial(mde.correlation.rotational_autocorrelation, order=1),
        vectors,
        segments=num_segments,
        skip=0.1,
        average=True,
    )

    times, results_f2 = mde.correlation.shifted_correlation(
        partial(mde.correlation.rotational_autocorrelation, order=2),
        vectors,
        segments=num_segments,
        skip=0.1,
        average=True,
    )

    df = pd.DataFrame(
        np.column_stack([times, results_f1, results_f2]), columns=column_labels
    )

    return df


def chi_4_susceptibility(
    coords: mde.coordinates.CoordinatesMap, q_val: float, num_segments: int = 500
) -> pd.DataFrame:
    """
    :param coords: CoordinatesMap generated by mdevaluate.
    :param q_val: Magnitude of the scattering vector, q.
    :param num_segments: Number of starting points in shifted correlation.
    :return DataFrame: TIMES df.iloc[ ':' , 0 ] | RESULTS df. iloc[ ':' , 1 ] | ROLLING AVERAGE df.iloc[ ':' , 2 ]
    """
    column_labels = ["t / ps", "X_4(t)"]

    times, results = mde.correlation.shifted_correlation(
        partial(mde.correlation.isf, q=q_val),
        coords,
        average=True,
        segments=num_segments,
    )

    df = pd.DataFrame(
        np.column_stack([times, results]),
        columns=column_labels,
    )

    return df


def van_hove_rotation(
    vectors: mde.coordinates.CoordinatesMap, num_segments: int = 500
) -> pd.DataFrame:
    """
    :param vectors: CoordinatesMap of vectorized residues generated by mdevaluate.
    :param num_segments: Number of starting points in shifted correlation.
    :return DataFrame: ANGLES = df.iloc[ ':' , 0 ] | TIMES = df.columns | F(Î¸, t) = df.iloc[ ':' , 1: ]
    """

    def _angle_dist(start, end, bins):
        scalar_product = (start * end).sum(axis=-1)
        angle = np.arccos(scalar_product)
        angle = angle[(angle >= 0) * (angle <= np.pi)]
        histogram, _ = np.histogram(angle * 360 / (2 * np.pi), bins)
        return 1 / len(start) * histogram

    bins = np.linspace(0, 180, 361)

    times, results = mde.correlation.shifted_correlation(
        function=partial(_angle_dist, bins=bins),
        frames=vectors,
        segments=num_segments,
        skip=0.1,
        points=8,
    )

    column_labels = ["angle / degrees"] + [f"{t / 1000:.0f} ns" for t in times]

    bin_centers = np.array(
        [0.5 * (bins[i] + bins[i + 1]) for i in range(len(bins) - 1)]
    )

    df = pd.DataFrame(np.column_stack([bin_centers, results.T]), columns=column_labels)

    return df


def van_hove_translation(
    coords: mde.coordinates.CoordinatesMap,
    num_segments: int,
    pore_diameter: float,
    num_bins: int = 3,
) -> pd.DataFrame:
    """
    Calculates van Hove translational dynamics based on centers of masses.

    Args:
        com: NumPy array containing the center of mass coordinates.
        diameter: Diameter of the pore.
        segments: Number of segments to divide the trajectory into.
        pore: Whether or not the system is a pore.

    Returns:
        * NDArray: A NumPy array containing the van Hove translational dynamics at the wall of the pore.
        * NDArray: A NumPy array containing the van Hove translational dynamics at the center of the pore.
        NDArray: A NumPy array containing the bins used.

        * If the system is a pore, otherwise only the overall van Hove translational array is returned.
    """
    radius_buffer = 0.1
    radius = pore_diameter / 2 + radius_buffer

    bins = np.arange(0.0, radius + radius / num_bins, radius / num_bins)

    times, results = mde.correlation.shifted_correlation(
        partial(mde.correlation.van_hove_self, bins=bins),
        coords,
        segments=num_segments,
        skip=0.1,
        points=8,
    )

    column_labels = ["r / nm"] + [f"{t / 1000:.0f} ns" for t in times]

    bin_centers = np.array(
        [0.5 * (bins[i] + bins[i + 1]) for i in range(len(bins) - 1)]
    )

    df = pd.DataFrame(np.column_stack([bin_centers, results.T]), columns=column_labels)

    return df


def radial_distribution_function(
    coords_1: mde.coordinates.CoordinatesMap,
    coords_2: mde.coordinates.CoordinatesMap = None,
    num_segments: int = 1000,
    mode: str = "total",
    column_label: str = "g(r)",
) -> pd.DataFrame:
    """
    Computes a radial distribution function (RDF) for the centers of masses.

    Args:
        com: NumPy array containing the center of mass coordinates.
        segments: Number of segments to divide the trajectory into.

    Returns:
        NDArray: Resulting RDF.
        float: Value for q constant.
        float: Value for g max.
    """
    if coords_2 is None:
        coords_2 = coords_1

    column_labels = ["r / nm", column_label]

    bins = np.arange(0, 2.2, 0.01)

    rdf = mde.distribution.time_average(
        partial(mde.distribution.rdf, bins=bins, mode=mode),
        coords_1,
        coords_2,
        segments=num_segments,
        skip=0.01,
    )

    df = pd.DataFrame(np.column_stack([bins[:-1], rdf]), columns=column_labels)

    return df


def spatial_density_function(
    coords: mde.coordinates.CoordinatesMap,
    res_atom_pairs: dict[str, list[str]],
    pore_diameter: float,
) -> pd.DataFrame:
    radius_buffer = 0.1
    radius = pore_diameter / 2 + radius_buffer

    bins = np.arange(0.0, radius, 0.025)

    out = np.array([0.5 * (bins[i] + bins[i + 1]) for i in range(len(bins) - 1)])

    column_labels = ["t / ps"]

    for residue, atoms in res_atom_pairs.items():
        for atom in atoms:
            column_labels.append(f"{residue}:{atom}")

            result = mde.distribution.time_average(
                partial(mde.distribution.radial_density, bins=bins),
                coords.subset(atom_name=atom, residue_name=residue),
                segments=1000,
                skip=0.01,
            )
            out = np.column_stack([out, result])

    df = pd.DataFrame(out, columns=column_labels)
    cols_to_drop = (df == 0).all(axis=0)
    df = df.loc[:, ~cols_to_drop]

    return df


def ref_plane_alignment(
    vectors: mde.coordinates.CoordinatesMap,
    normal_vector: list = [0, 0, 1],
    num_segments: int = 500,
) -> pd.DataFrame:
    """
    :param normal_vector: Vector normal to the plane of interest. E.g., [0, 0, 1] (Z-axis vector) is normal to the xy-plane.
    """

    def _plane_alignment_angle(start, end, normal_vector, bins):
        angle = np.arccos(np.abs((end * normal_vector).sum(axis=-1)))
        angle = np.pi / 2 - angle
        angle = angle[(angle >= 0) * (angle <= np.pi / 2)]
        hist, _ = np.histogram(angle * 360 / (2 * np.pi), bins)
        return 1 / len(end) * hist

    bins = np.linspace(0, 90, 181)
    bin_centers = bins[1:] - (bins[1] - bins[0]) / 2

    times, results = mde.correlation.shifted_correlation(
        partial(_plane_alignment_angle, normal_vector=normal_vector, bins=bins),
        vectors,
        segments=num_segments,
        skip=0.1,
        points=10,
    )

    column_labels = [r"\theta / degrees"] + [f"{t / 1000:.0f} ns" for t in times]

    df = pd.DataFrame(np.column_stack([bin_centers, *results]), columns=column_labels)

    return df


def ref_vector_alignment(
    vectors: mde.coordinates.CoordinatesMap,
    ref_vector: list = [0, 0, 0],
    num_segments: int = 500,
) -> pd.DataFrame:
    def _ref_alignment_angle(start, end, ref_vector, bins):
        angle = np.arccos((end * ref_vector).sum(axis=-1))
        angle = angle[(angle >= 0) * (angle <= np.pi)]
        hist, _ = np.histogram(angle * 360 / (2 * np.pi), bins)
        return 1 / len(end) * hist

    bins = np.linspace(0, 180, 361)
    bin_centers = bins[1:] - (bins[1] - bins[0]) / 2

    times, results = mde.correlation.shifted_correlation(
        partial(_ref_alignment_angle, ref_vector=ref_vector, bins=bins),
        vectors,
        segments=num_segments,
        skip=0.1,
        points=10,
    )

    column_labels = ["angle / degrees"] + [f"{t / 1000:.0f} ns" for t in times]

    df = pd.DataFrame(np.column_stack([bin_centers, *results]), columns=column_labels)

    return df
