import mde.mdevaluate as mde

from abc import ABC, abstractmethod
from pathlib import Path
from typing import Optional

from .basemodels import Params, Metadata, Results
from .output import SummaryLogger, next_backup_name
from ...functions.plotting import plot_from_log


class BaseAnalysis(ABC):
    def __init__(
        self,
        coords: mde.coordinates.CoordinatesMap,
        coords_type: str,
        params: Params,
        num_segments: int = 500,
        skip: float = 0.1,
    ):
        """
        :param coords: CoordinateFrame object generated by mdevaluate.
        :param coords_type: "com", "vectorized", or "explicit".
        :param params: Initial parameters (i.e., residues or atoms used to generate coords_type) organized in Params basemodel.
        :param num_segments: Number of starting points in shifted correlation.
        :param skip: Fraction of the trajectory to skip at its beginning.
        """
        self._coords = coords
        self._coords_type = coords_type
        self._num_segments = num_segments
        self._skip = skip

        self._params = params
        self._params.num_segments = num_segments
        self._params.skip = skip

        self._metadata = Metadata()
        self._results = Results()

    def _set_radial_params(
        self,
        radially_resolved: bool = False,
        pore_diameter: float = None,
        num_bins: int = None,
        radius_buffer: int = None,
    ):
        self._params.radially_resolved = radially_resolved
        self._params.pore_diameter = pore_diameter
        self._params.num_bins = num_bins
        self._params.radius_buffer = radius_buffer

    @abstractmethod
    def calculate(self):
        raise NotImplementedError

    @abstractmethod
    def _plot_func(self):
        raise NotImplementedError

    @property
    def has_results(self):
        return hasattr(self, "_results_df")

    def save(
        self,
        output_directory: Path,
        module_name: Optional[str] = None,
        filename: str = "results.csv",
    ):
        """
        Save results with backup and log metadata.

        :param output_directory: Folder to write outputs and summary log.
        :param module_name: Optional module name (used for log grouping).
        :param filename: Output CSV filename.
        """
        if not self.has_results:
            raise LookupError("Run calculate() before saving.")

        if not hasattr(self, "_results"):
            self._results = Results

        module_name = module_name or self.__class__.__name__.replace("Function", "")

        out_dir = Path(output_directory) / module_name
        out_dir.mkdir(parents=True, exist_ok=True)

        output_path = next_backup_name(out_dir / filename)
        self._results_df.to_csv(output_path, index=False)

        self._metadata.outputs = str(output_path)

        logger = SummaryLogger(output_directory)
        logger.log(
            module=module_name,
            params=self._params,
            metadata=self._metadata,
            results=self._results,
        )

    def plot(self, output_directory: Path):
        module_name = self.__class__.__name__.replace("Function", "")

        plot_from_log(
            module_name=module_name,
            output_directory=output_directory,
            current_params=self._params.model_dump(),
            plot_func=self._plot_func,
        )

    def should_run(self, output_directory: Path, override: bool = False) -> bool:
        if override:
            return True

        module_name = self.__class__.__name__.replace("Function", "")
        logger = SummaryLogger(output_directory)

        for entry in logger.data.get(module_name, []):
            if entry.get("params") == self._params.model_dump():
                return False

        return True
